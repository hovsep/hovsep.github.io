<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FMesh – Lego for Programmers | Ovsep Avakian</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../../css/base.css">
    <link rel="stylesheet" href="../../css/components.css">
    <link rel="stylesheet" href="../../css/blog.css">
</head>
<body class="blog blog-post">
    <div class="noise"></div>
    
    <main>
        <nav class="breadcrumb">
            <a href="../../">~</a>
            <span>/</span>
            <a href="../">blog</a>
            <span>/</span>
            <span class="current">fmesh-lego-for-programmers</span>
        </nav>

        <article>
            <header>
                <p class="post-date">January 7, 2026</p>
                <h1>FMesh – Lego for Programmers</h1>
            </header>

            <div class="content">
                <p>
                    About a year ago, I quit my job and started looking for a new one. Between interviews, I suddenly had something rare: time. Naturally, I started thinking about a pet project.
                </p>

                <p>
                    I had always liked building things. As a kid, I played with gears, motors, and random mechanical parts. My father worked as a car mechanic and regularly brought home discarded components, which felt like treasure. I even dreamed of building my own car. I also played with construction toys like Lego, as most kids did.
                </p>

                <p>
                    That interest never really disappeared. I once tried to build a perpetual motion machine. It did not work. Thermodynamics eventually won. Still, the desire to assemble systems from smaller parts stuck with me, and it probably influenced my decision to become a software engineer. I could imagine myself in other engineering fields too: mechanics, aviation, anything where systems came together and did something real.
                </p>

                <p>
                    Programming always felt like building. I could snap components together, connect them, and watch a system work. The problem wasn’t the act itself—it was what I was building. After more than ten years of web apps, microservices, and fintech systems, everything had the same shape: APIs, queues, workers, and glue code. The novelty had worn off.
                </p>

                <p>
                    I wanted something different. Not another framework forcing me into controllers, routers, models, and views. I wanted something lower-level and flexible—something that let me model real-world systems: an elevator, an engine, a car built from that engine, or even electronic circuits where components exchanged signals and logic flowed naturally. Could I build, test, and debug that like software?
                </p>

                <p>
                    That was the moment the idea clicked.
                </p>

                <p>
                    <strong>I wanted Lego for programmers.</strong>
                </p>

                <p>
                    Better than Lego, actually. Lego with unlimited blocks. Blocks I could design myself, with any behavior or complexity I wanted. Naturally, I decided to build it in Go, my favorite compiled language at the time.
                </p>

                <h2>Finding the Right Abstraction</h2>

                <p>
                    I started by looking at existing frameworks and libraries in the same space: actor systems, Flow-Based Programming frameworks, and various concurrency helpers. On paper, many of them looked promising. In practice, they all shared the same fundamental problem: they didn't abstract Go's concurrency model—they exposed it.
                </p>
                <p>
                    Flow-Based Programming frameworks were especially interesting. I read <a href="https://jpaulm.github.io/fbp/" target="_blank" rel="noopener">J. Paul Morrison's original FBP book</a> and explored several Go implementations. Conceptually, FBP was close to what I wanted. But most Go-based implementations treated concurrency as a first-class concern for the user. I would have been expected to reason about channels, goroutines, and scheduling directly. That defeated the purpose.
                </p>

                <p>
                    Most of these frameworks were thin layers over goroutines and channels. Components were often long-running goroutines. Communication happened via channels that the user had to wire, buffer, close, and synchronize correctly. Technically, this was flexible. Practically, it pushed all the hard parts back onto the user.
                </p>

                <p>
                    <strong>
                    Go already gave me goroutines and channels. I didn't need a framework to remind me they existed.
                    </strong>
                </p>

                <p>
                    It became clear that building anything non-trivial on top of such frameworks would be a nightmare. I would constantly have to think about:
                </p>

                <ul>
                    <li>Who owned a channel</li>
                    <li>Who closed it, and when</li>
                    <li>What happened if a sender blocked</li>
                    <li>How many goroutines were running at any moment</li>
                    <li>Whether a select statement could starve another path</li>
                </ul>

                <p>
                    This is what “simple” looks like in a typical Go FBP library:
                    <div class="gist-wrapper">
                        <script src="https://gist.github.com/hovsep/b67018a5355e6fc701883a06a7c99108.js"></script>
                    </div>
                </p>

                <p>
                    That's fine for system software or infrastructure, but it completely killed the fun when I wanted to model something like an elevator, a production line, or an electronic circuit.
                </p>

                <p>
                    I wanted concurrency to be <em>structural</em>, not <em>procedural</em>. Something I could get by how I connected components, not by how carefully I juggled channels.
                </p>

                <p>
                    So I stripped the model down to the bare minimum. The system has only two fundamental concepts:
                </p>

                <ul>
                    <li><strong>Components:</strong> units of behavior</li>
                    <li><strong>Signals:</strong> data flowing between components</li>
                </ul>

                <p>
                    Components have named input and output ports that act as communication points and allow connecting components into a graph. A component activates when it has at least one input signal and is completely unaware of the rest of the graph.
                </p>

                <p>
                    The core of the component is its activation function.
                    Inside that function, user code runs synchronously. No goroutines. No channels. No select statements. Just normal code.
                </p>

                <p>
                    A typical activation function does three things:
                </p>

                <ol>
                    <li>Read input signals</li>
                    <li>Execute logic</li>
                    <li>Emit output signals</li>
                </ol>

                <p>
                    Example:
                    <div class="gist-wrapper">
                        <script src="https://gist.github.com/hovsep/d712a163a1a117be94a1e4e553d3b5de.js"></script>
                    </div>
                </p>

                <p>
                    Those outputs become inputs for other components, triggering further activations. The process continues until no component has pending inputs. At that point, the graph reaches a stable state and results can be collected.
                    <div class="gist-wrapper">
                        <script src="https://gist.github.com/hovsep/3618456fe6b37239492a99f85b646f1b.js"></script>
                    </div>
                </p>

                <h2>Structural Concurrency</h2>

                <p>
                    This execution model gives concurrency almost as a side effect of structure.
                </p>

                <p>
                    Every component that has input signals is eligible for activation. All eligible components are scheduled concurrently, each in its own goroutine. Because input ports belong to a single component, there is no shared state by default. As long as components don’t share a mutable state, data races are avoided by design.
                </p>

                <p>
                    Inside a component, you write ordinary, synchronous Go code. There are no goroutines, no channels, no select statements, and no explicit synchronization. Scheduling, execution, and isolation are handled entirely by the framework.
                </p>

                <p>
                    Synchronization emerges from how you connect components:
                </p>

                <ul>
                    <li>
                        <strong>Pipelines</strong> naturally enforce sequential execution
                        <img width="500px" src="image/pipeline.png" alt="Pipeline">
                    </li>
                    <li><strong>Fan-out</strong> represents parallel work
                        <img width="300px" src="image/fan-out.png" alt="Fan-out">
                    </li>
                    <li><strong>Fan-in</strong> collects results from concurrent stages
                        <img width="300px" src="image/fan-in.png" alt="Fan-in">
                    </li>
                </ul>

                <p>
                    This makes concurrency <em>structural</em>. You don't describe how things run in parallel. You describe what is connected to what, and parallelism follows automatically.
                </p>

                <p>
                    The result is a model where you can focus on the system you're building instead of the mechanics of making it safe to run. You think in terms of data flow and composition, not lifecycles and synchronization rules. That shift is the whole point.
                </p>

                <h2>What It Became</h2>

                <p>
                    Out of this model came <strong>Functional Mesh</strong>, or <a href="../../projects/fmesh/">FMesh</a>.
                </p>

                <p>
                    While many parts of the design evolved over time, the concurrency model never changed. It turned out to be the most stable and valuable part of the system.
                </p>

                <p>
                    FMesh is not a classical FBP framework. It can be better described as an FBP-inspired system. Components are not long-running processes. They activate, do their work, emit signals, and finish. This makes the system closer in spirit to computational graphs than to traditional process networks.
                </p>

                <p>
                    As the project evolved, my focus shifted toward state machines, simulations, and game-engine-like models. These are systems built from many small, interacting parts that react to events rather than run forever.
                </p>

                <p>
                    FMesh was never intended to be a high-performance Go framework or a solution for synchronization-heavy workloads. That was a conscious choice. Its purpose is to make complex behavior easy to express. FMesh favors clarity over raw throughput and structure over clever concurrency. It is a tool for modeling state, interactions, and logic in a way that stays simple, composable, and enjoyable to work with.
                </p>

                <h2>Developer Experience</h2>

                <p>
                    Over time, I added some conveniences:
                </p>

                <p>
                    <strong>Visualization:</strong> You can export a mesh as a <a href="https://graphviz.org/" target="_blank" rel="noopener">DOT graph</a> or image and explore the structure visually. Very useful for understanding what you actually built.
                    Looks a bit ugly, but I love the ability to look at my program and follow the data flow.
                    <img src="https://raw.githubusercontent.com/hovsep/fmesh-examples/refs/heads/main/can_bus/advanced/graph.svg" alt="FMesh graph" />


                </p>

                <p>
                    <strong>Chained API:</strong> Not idiomatic Go, yes, but it allows fluent code without checking errors on every line. Errors bubble up, which is good enough.
                    <div class="gist-wrapper">
                        <script src="https://gist.github.com/hovsep/7f7c2da121a46556cd70485c75786643.js"></script>
                    </div>
                </p>

                <p>
                    <strong>Component-level state:</strong> Components started as pure functions, but I quickly needed state between activations. External variables were ugly and error-prone, so I added a simple key-value store per component (optional, of course).
                </p>

                <p>
                    <strong>Hooks:</strong> Small functions that execute before and after important events, useful for debugging and instrumentation.
                </p>

                <h2>Development Process</h2>

                <p>
                    I’m currently the only contributor and user, which is fine for a project at this stage.
                </p>

                <p>
                    I maintain two repositories:
                </p>

                <ul>
                    <li><a href="https://github.com/hovsep/fmesh" target="_blank" rel="noopener">github.com/hovsep/fmesh</a></li>
                    <li><a href="https://github.com/hovsep/fmesh-examples" target="_blank" rel="noopener">github.com/hovsep/fmesh-examples</a></li>
                </ul>

                <p>
                    When I finish a feature or bugfix in the framework, I deliberately switch roles and become an FMesh user for a while. I build example programs to stress the system and see where it breaks, where it feels awkward, and where the abstractions leak.
                </p>

                <p>
                    I started with small examples like a <a href="https://github.com/hovsep/fmesh-examples/tree/main/pipeline" target="_blank" rel="noopener">pipeline</a> and a <a href="https://github.com/hovsep/fmesh-examples/tree/main/load_balancer" target="_blank" rel="noopener">load balancer</a>, then moved on to a larger project: a realistic <a href="https://github.com/hovsep/fmesh-examples/tree/main/can_bus" target="_blank" rel="noopener">CAN bus</a> simulation. Right now, I'm working on an even bigger example, a human body simulation, which deserves its own post.
                </p>

                <p>
                    Building examples is how I validate the design. It's the fastest way to find bugs, expose pain points, and discover patterns that should probably become first-class features. If something feels annoying or unnatural while using FMesh, that's a signal that the framework — not the example — needs to change.
                </p>

                <h2>Looking Ahead</h2>

                <p>
                    I'm honestly surprised I'm still working on this project after more than a year. It still feels like playing with Lego, and that's reason enough to keep going.
                </p>

                <p>
                    I hope FMesh will grow beyond a personal playground and more people will find it useful.
                </p>

                <p>
                    <strong>Keep building.</strong>
                </p>
            </div>

            <nav class="post-nav">
                <a href="../">← Back to all posts</a>
            </nav>
        </article>
    </main>

    <footer>
        <p>© 2026 Ovsep Avakian</p>
    </footer>

</body>
</html>
